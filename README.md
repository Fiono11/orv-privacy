# orv-privacy

An example cryptosystem to add amount privacy while being able to reveal sums of commitments (representative weights).

## Algorithm description

Each representative generates a key relative to basepoint `H`, and uses a verifiable secret sharing algorithm (in this codebase Feldman's scheme) to ensure that the key can be recovered even if they disappear.
This verifiable secret sharing algorithm must also verify that the rep knows the private key `k` for which their key `K = kH`, as otherwise the commitments might be malleable.

The basepoint for the commitment blinding key `P` is created by summing `Kn * Hs(H(K1 || K2 || ... || Kn) || Kn)` where `H(x)` is a cryptographic hash function and `Hs(x) = H(x) % l`, as seen in MuSig to prevent rogue key attacks.

Balance commitments are generated normally, and signing as them to prove they're a commitment can be done normally (though it could be modified to make it perfectly binding).
However, the range proofs are unusual.
I'll be referring to the variables of the commitments as `b*G + x*P` where `b` is the balance, `G` is the normal basepoint, and `x` is the blinding key (`P` was defined earlier as the aggregated rep keys).

Range proofs are based on Borromean ring signatures, and are done on the basepoint `P`.
However, these ring signatures are modified to make it "linkable" based on the blinding key to some degree.
This isn't used to link double spends, but instead to prove what `x*G` is
(remember `G` is not the normal basepoint for this, `P` is).
`I = x*G` which I will refer to as the key image is contained in the range proof.
To prove this value, each time a challenge `c` is generated by hashing one or more `r*P + c*K` values with the previous `c`, `r*G + c*I` is also hashed in.
This is equivalent to the technique used to make Monero's ring signatures linkable.

All representatives will then total the commitments and key images for each representative (not just for themselves).
A scheme like epoch blocks would be needed to get representatives to agree on a point in time to calculate this.
Once that's done, for each total key image `I`, each representative releases `D = kI` where `k` is their key.
To prove that this released `S` value is correct, the representative generates a random scalar `a`, then computes `c = Hs(a*H || a*I)` and `s = a + c*k` and releases both.
This can be verified by validating `c = Hs((s*H - c*K) || (s*I - c*D))`.
This is very similar to the linkable borromean ring signatures mentioned before.
Any representative that does not release `D` or for which verification fails will have their key publicly recovered by the others using the secret sharing scheme described at the start.

Finally, `b*G = c - D1 - D2 - ... - Dn` is computed for each total commitment.
This works because if we call the aggregated rep secret keys `p`, `c - pI = (b*G + x*P) - p*x*H = b*G + x*p*H - p*x*H = b*G`.
`p` is never computed, but its components multiplied by `I` are the decryption shares `D1 + D2 + ... + Dn = pI`.
To recover `b` itself, the total weight, a precomputed lookup table can be utilized.
To reduce the size of the lookup table, it can be limited to points which start with the `00` byte (and this byte doesn't need to be stored).
Then, `G` is added to `b*G` until it starts with a `00` byte too (and a count is kept of how many times this was done).
That modified `b*G` will be in the lookup table, and the scalar in the lookup table will have the count subtracted from it to recover `b`, the total weight.
